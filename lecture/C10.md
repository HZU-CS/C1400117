# 10.字符串及其函数



## 10.1 字符串

### 字符数组

```c
char word[] = {'H', 'e', 'l', 'l', 'o', '!'};
```

| 数组单元 | 字符 |
| -------- | ---- |
| word[0]  | H    |
| word[1]  | e    |
| word[2]  | l    |
| word[3]  | l    |
| word[4]  | o    |
| word[5]  | !    |

### 字符串

```c
char word[] = {'H', 'e', 'l', 'l', 'o', '!'};
```

| 数组单元 | 字符 |
| -------- | ---- |
| word[0]  | H    |
| word[1]  | e    |
| word[2]  | l    |
| word[3]  | l    |
| word[4]  | o    |
| word[5]  | !    |
| word[6]  | \0   |

字符串是以0（整数0）结尾的⼀串字符

- 0或'\0'是⼀样的，但是和'0'不同

0标志字符串的结束，但它不是字符串的⼀部分

- 计算字符串⻓度的时候不包含这个0

字符串以数组的形式存在，以数组或指针的形式访问

- 更多的是以指针的形式

string.h头文件⾥有很多处理字符串的函数

### 字符串变量

```c
char *str = “Hello”;

char word[] = “Hello”;

char line[10] = “Hello”;
```

### 字符串常量

例如"Hello"会被编译器变成⼀个字符数组放在某处，这个数组的⻓度是6，结尾还有表⽰结束的\0

两个相邻的字符串常量会被⾃动连接起来

⾏末的\表⽰下⼀⾏还是这个字符串常量，注意\会记录下两行之间的所有字符串

```c
"asdasdsadasdadsadaasd\
    asdasdasdasdasdasdasd"
```

C语⾔的字符串是以字符数组的形态存在的

- 不能⽤运算符对字符串做运算
- 通过数组的⽅式可以遍历字符串

唯⼀特殊的地⽅是字符串字⾯量可以⽤来初始化字符数组

以及标准库提供了⼀系列字符串函数

```c
char* s = "Hello, world!";
```

s 是⼀个指针，初始化为指向⼀个字符串常量

- 由于这个常量所在的地⽅，所以实际上s是 const char* s ，但是由于历史的原因，编译器接受不带const的写法
- 但是试图对s所指的字符串做写⼊会导致严重的后果

如果需要修改字符串，应该⽤数组：

```c
char s[] = "Hello, world!";
```

### 指针还是数组

```c
char *str = "Hello";

char word[] = "Hello";
```

数组：这个字符串在这⾥

- 作为本地变量空间⾃动被回收

指针：这个字符串不知道在哪⾥

- 处理参数
- 动态分配空间

如果要构造⼀个字符串->数组

如果要处理⼀个字符串->指针

### char*是字符串

字符串可以表达为char*的形式

char*不⼀定是字符串

- 本意是指向字符的指针，可能指向的是字符的数组（就像int*⼀样）
- 只有它所指的字符数组有结尾的0，才能说它所指的是字符串

### 字符串运算

#### 字符串赋值

```c
char *t = "title";

char *s = t;
```

并没有产⽣新的字符串，只是让指针s指向了t所指的字符串，对s的任何操作就是对t做的

### 字符串输入输出

```c
char string[8];

scanf("%s", string);

printf("%s", string); 
```

scanf读⼊⼀个单词（到空格、tab或回⻋为⽌）

scanf是不安全的，因为不知道要读⼊的内容的⻓度。读取超过字符串长度的字符串会导致UB。

#### 安全的输入

```c
char string[8];

scanf("%7s", string);
```

在%和s之间的数字表⽰最多允许读⼊的字符的数量，这个数字应该⽐数组的⼤⼩⼩⼀

- 下⼀次scanf从哪⾥开始？



## 10.2 字符串函数



## 10.3 第十章练习