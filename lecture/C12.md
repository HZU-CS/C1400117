# 12.程序项目结构

- [12.程序项目结构](#12%e7%a8%8b%e5%ba%8f%e9%a1%b9%e7%9b%ae%e7%bb%93%e6%9e%84)
  - [12.1 全局变量和静态本地变量](#121-%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e5%92%8c%e9%9d%99%e6%80%81%e6%9c%ac%e5%9c%b0%e5%8f%98%e9%87%8f)
    - [全局变量](#%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f)
      - [全局变量初始化](#%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96)
      - [被隐藏的全局变量](#%e8%a2%ab%e9%9a%90%e8%97%8f%e7%9a%84%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f)
    - [静态本地变量](#%e9%9d%99%e6%80%81%e6%9c%ac%e5%9c%b0%e5%8f%98%e9%87%8f)
      - [*返回指针的函数](#%e8%bf%94%e5%9b%9e%e6%8c%87%e9%92%88%e7%9a%84%e5%87%bd%e6%95%b0)
    - [tips](#tips)
  - [12.2 宏](#122-%e5%ae%8f)
    - [编译预处理指令](#%e7%bc%96%e8%af%91%e9%a2%84%e5%a4%84%e7%90%86%e6%8c%87%e4%bb%a4)
    - [没有值的宏](#%e6%b2%a1%e6%9c%89%e5%80%bc%e7%9a%84%e5%ae%8f)
    - [带参数的宏](#%e5%b8%a6%e5%8f%82%e6%95%b0%e7%9a%84%e5%ae%8f)
      - [像函数的宏](#%e5%83%8f%e5%87%bd%e6%95%b0%e7%9a%84%e5%ae%8f)
      - [错误定义的宏](#%e9%94%99%e8%af%af%e5%ae%9a%e4%b9%89%e7%9a%84%e5%ae%8f)
      - [带参数的宏的原则](#%e5%b8%a6%e5%8f%82%e6%95%b0%e7%9a%84%e5%ae%8f%e7%9a%84%e5%8e%9f%e5%88%99)
    - [分号？](#%e5%88%86%e5%8f%b7)
    - [其他编译预处理指令](#%e5%85%b6%e4%bb%96%e7%bc%96%e8%af%91%e9%a2%84%e5%a4%84%e7%90%86%e6%8c%87%e4%bb%a4)
      - [条件编译](#%e6%9d%a1%e4%bb%b6%e7%bc%96%e8%af%91)
  - [12.3 项目、头文件、声明](#123-%e9%a1%b9%e7%9b%ae%e5%a4%b4%e6%96%87%e4%bb%b6%e5%a3%b0%e6%98%8e)
    - [项目](#%e9%a1%b9%e7%9b%ae)
      - [多个.c文件](#%e5%a4%9a%e4%b8%aac%e6%96%87%e4%bb%b6)
    - [头文件](#%e5%a4%b4%e6%96%87%e4%bb%b6)
      - [#include](#include)
      - [""还是<>](#%22%22%e8%bf%98%e6%98%af)
      - [#include的误区](#include%e7%9a%84%e8%af%af%e5%8c%ba)
      - [不对外公开的函数](#%e4%b8%8d%e5%af%b9%e5%a4%96%e5%85%ac%e5%bc%80%e7%9a%84%e5%87%bd%e6%95%b0)
    - [声明](#%e5%a3%b0%e6%98%8e)
      - [变量的声明](#%e5%8f%98%e9%87%8f%e7%9a%84%e5%a3%b0%e6%98%8e)
      - [声明和定义的区别](#%e5%a3%b0%e6%98%8e%e5%92%8c%e5%ae%9a%e4%b9%89%e7%9a%84%e5%8c%ba%e5%88%ab)
      - [重复声明](#%e9%87%8d%e5%a4%8d%e5%a3%b0%e6%98%8e)
        - [标准头文件结构](#%e6%a0%87%e5%87%86%e5%a4%b4%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84)
  - [12.4 第十二章练习](#124-%e7%ac%ac%e5%8d%81%e4%ba%8c%e7%ab%a0%e7%bb%83%e4%b9%a0)

## 12.1 全局变量和静态本地变量

### 全局变量

定义在函数外⾯的变量是全局变量

全局变量具有全局的⽣存期和作⽤域

- 它们与任何函数都⽆关
- 在任何函数内部都可以使⽤它们

#### 全局变量初始化

没有做初始化的全局变量会得到0值

- 指针会得到NULL值

只能⽤编译时刻已知的值来初始化全局变量

它们的初始化发⽣在main函数之前

#### 被隐藏的全局变量

如果函数内部存在与全局变量同名的变量，则全局变量被隐藏

### 静态本地变量

在本地变量定义时加上static修饰符就成为静态本地变量

当函数离开的时候，静态本地变量会继续存在并保持其值

静态本地变量的初始化只会在第⼀次进⼊这个函数时做，以后进⼊函数时会保持上次离开时的值

静态本地变量实际上是特殊的全局变量

它们位于相同的内存区域

静态本地变量具有全局的⽣存期，函数内的局部作⽤域

- static在这⾥的意思是局部作⽤域（本地可访问）

#### *返回指针的函数

关于函数返回值的建议

1. 返回本地变量的地址是危险的

2. 返回全局变量或静态本地变量的地址是安全的

3. 返回在函数内malloc的内存是安全的，但是容易造成问题

所以比较推荐的做法是返回传⼊的指针

### tips

不要使⽤全局变量来在函数间传递参数和结果

尽量避免使⽤全局变量

- 丰⽥汽⻋的案⼦

*使⽤全局变量和静态本地变量的函数是线程不安全的

## 12.2 宏

### 编译预处理指令

\#开头的是编译预处理指令

它们不是C语⾔的成分，但是C语⾔程序离不开它们

```c
#define // ⽤来定义⼀个宏
```

#define

\#define *名字* *值*

注意没有结尾的分号，因为不是C的语句，名字必须是⼀个单词，值可以是各种东⻄。

在C语⾔的编译器开始编译之前，编译预处理程序（C preprocessor）会把程序中的名字换成值。

宏是一种完全的文本替换的脚本。

```shell
gcc -save-temps
```

gcc命令可以查看中间内容查看宏的替换操作。

如果⼀个宏的值中有其他的宏的名字，也是会被替换的

如果⼀个宏的值超过⼀⾏，最后⼀⾏之前的⾏末需要加\

宏的值后⾯出现的注释不会被当作宏的值的⼀部分

### 没有值的宏

```c
#define _DEBUG
```

这类宏是⽤于条件编译的，后⾯有其他的编译预处理 指令来检查这个宏是否已经被定义过了。其他预定义的宏如下

```c
__LINE__ 
__FILE__ 
__DATE__ 
__TIME__ 
__STDC__
```

### 带参数的宏

#### 像函数的宏

```c
#define cube(x) ((x)*(x)*(x)) // 宏可以带参数
```

#### 错误定义的宏

```c
#define RADTODEG(x) (x * 57.29578)

#define RADTODEG(x) (x) * 57.29578
```

#### 带参数的宏的原则

***一切都要括号***

1. 整个值要括号
2. 参数出现的每个地⽅都要括号

修改成下面这个样子

```c
#define RADTODEG(x) ((x) * 57.29578)
```

宏还可以带多个参数

```c
#define MIN(a,b) ((a)>(b)?(b):(a))
```

也可以组合（嵌套）使⽤其他宏

### 分号？

不要在最后面加分号，不然可以参照下面这个例子

```c
#define PRETTY_PRINT(msg) printf(msg);

if (n < 10)
    PRETTY_PRINT("n is less than 10");
else
    PRETTY_PRINT("n is at least 10");
```

多加分号容易对if/else判断造成错误。（前面循环中讲到的do-while可以用上，使用do{...}while(0)减少因为;造成问题）

宏在⼤型程序的代码中使⽤⾮常普遍

可以⾮常复杂，如“产⽣”函数

- 在#和##这两个运算符的帮助下

宏的受欢迎程度在中西不一样，西方普遍用得更多一点。现代部分宏会被inline函数替代，inline函数本课不进行介绍，有兴趣的同学请自行了解。

### 其他编译预处理指令

#### 条件编译

```c
#error
#warning
```

## 12.3 项目、头文件、声明

### 项目

#### 多个.c文件

### 头文件

把函数原型放到⼀个头⽂件（以.h结尾）中，在需要调⽤这个函数的源代码⽂件（.c⽂件）中#include这个头⽂件，就能让编译器在编译的时候知道函数的原型。

#### #include

\#include是⼀个编译预处理指令，和宏⼀样，在编译之前就处理了

它把那个⽂件的全部⽂本内容原封不动地插⼊到它所在的地⽅

- 所以也不是⼀定要在.c⽂件的最前⾯#include

#### ""还是<>

\#include有两种形式来指出要插⼊的⽂件

- ""要求编译器⾸先在当前目录（.c⽂件所在的目录）寻找这个⽂件，如果没有，到编译器指定的⺫录去找
- <>让编译器只在指定的目录去找

编译器⾃⼰知道⾃⼰的标准库的头⽂件在哪⾥，环境变量和编译器命令⾏参数也可以指定寻找头⽂件的目录。

#### #include的误区

\#include不是⽤来引⼊库的，stdio.h⾥只有printf的原型，printf的代码在另外的地⽅，某个.lib(Windows)或.a(Unix)中。

现在的C语⾔编译器默认会引⼊所有的标准库，\#include <stdio.h>只是为了让编译器知道printf函数的原型，保证你调⽤时给出的参数值是正确的类型。在使⽤和定义这个函数的地⽅都应该#include这个头⽂件。

⼀般的做法就是任何.c都有对应的同名的.h，把所有对外公开的函数的原型和全局变量的声明都放进去。

#### 不对外公开的函数

在函数前⾯加上static就使得它成为只能在所在的编译单元中被使⽤的函数

在全局变量前⾯加上static就使得它成为只能在所在的编译单元中被使⽤的全局变量

### 声明

#### 变量的声明

```c
int i; // 变量的定义

extern int i; // 变量的声明
```

#### 声明和定义的区别

声明是不产⽣代码的东⻄

- 函数原型
- 变量声明
- 结构声明
- 宏声明
- 枚举声明
- 类型声明
- inline函数

定义是产生代码的东西。

只有声明可以被放在头⽂件中，这是规则不是法律，防止⼀个项目中多个编译单元⾥有重名的实体。

- *某些编译器允许⼏个编译单元中存在同名的函数，或者⽤weak修饰符来强调这种存在

#### 重复声明

同⼀个编译单元⾥，同名的结构不能被重复声明。如果你的头⽂件⾥有结构的声明，很难这个头⽂件不会在⼀个编译单元⾥被#include多次。

所以需要“标准头⽂件结构”

##### 标准头文件结构

运⽤条件编译和宏，保证这个头⽂件在⼀个编译单元中只会被#include⼀次

\#pragma once也能起到相同的作⽤，但是不是所有的编译器都⽀持。

#include防范（#include guard）示例如下

```c
#ifndef __LIST_HEAD__
#define __LIST_HEAD__

#include "node.h"

typedef struct _list {
    Node* head;
    Node* tail;
} List;

#endif
```

*前向声明

```c
#ifndef __LIST_HEAD__
#define __LIST_HEAD__

struct Node;

typedef struct _list {
    Node* head;
    Node* tail;
} List;

#endif
```

因为在这个地⽅不需要具体知道Node是怎样的，所以可以⽤struct Node来告诉编译器Node是⼀个结构.

## 12.4 第十二章练习

1. 用宏来代替你以前写过的函数
2. 查看全局变量和静态本地变量的地址，看看和普通本地变量的地址有何不同
3. 熟悉C项目的构建